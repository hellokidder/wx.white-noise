<style lang="less">
.position {
  position: fixed;
  bottom: 0;
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  background-image: url('http://localhost:5000/WechatIMG11.png');
  background-size: 100% 100%;
}

.markposition {
  position: fixed;
  bottom: 0;
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
}

.top {
  position: fixed;
  bottom: 0;
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
}

.mark {
  font-size: 35px;
  color: white;
}

.text {
  width: 100%;
  height: 10%;
}

.yuan {
  width: 200px;
  height: 200px;
  border: 2px solid rgba(255, 255, 255, 0.5);
  border-radius: 100px;
}

.center {
  display: flex;
  justify-content: center;
  align-items: center;
}

.time {
  color: white;
  border-bottom: 1px solid white;
  border-top: 1px solid white;
  // border-radius: 15px;
  // border-left-color: rgba(255, 255, 255, 0);
  // border-right-color: rgba(255, 255, 255, 0);
  margin-top: 5%;
  font-size: 11px;
  font-weight: bold;
}

.timefloor {
  margin-top: 5%;
  color: white;
  font-size: 20px;
}

.key {
  margin-top: 38%;
  display: flex;
  flex-direction: row;
  color: white;
  width: 100%;
}
.font{
  font-size: 25px;
}
.txt{
  border: 1px solid white;
  border-radius: 10px;
}
.nongli{
  color: white;
  font-size: 12px;
  margin-top: 20%;
}
</style>
<template>
  <view>
    <view wx:if="{{showImge}}">
      <image src="../image/bg.jpeg" class="top"></image>
    </view>
    <view wx:else class="position" @touchstart="touchstart" @touchmove="touchmove" @touchend="touchend">
      <view class="markposition" style="background-color:{{bgcolor}}">
        <view class="top">
          <view class="text"></view>
          <view class="yuan center" style="background-color:{{circlecolor}}">
            <view class="center" style="display: flex; flex-direction: column;">
              <view><text class="mark">{{text}}</text></view>
              <view class="time"><text>{{dates}}</text></view>
              <view class="nongli"><text>农历八月二十九</text></view>
            </view>
          </view>
          <view class="center timefloor">
            <text>{{time}} </text>
          </view>
          <view wx:if="{{key === 0}}" @tap="time" class="key center font">
            <text>{{kStatus[key]}}</text>
          </view>
          <view wx:else class="key center font">
            <view @tap="time" style="margin-right: 8%;">
              <text>{{kStatus[key]}}</text>
            </view>
            <view @tap="timerEnd" style="margin-left: 8%;">
              <text>{{endKey}}</text>
            </view>
          </view>
          <view>
            <text></text>
          </view>
        </view>
      </view>
    </view>
  </view>
</template>
<script>
import wepy from 'wepy'

const initialTimeText = '20 : 00'
const initialTime = 20
const secondsPerMin = 60
const timeUplimit = 60
const timeLowlimit = 0
const ksStart = 0
const ksPause = 1
const ksContinue = 2
const xPos = 0
const yPos = 1
const changeTimePoint = 5
const changeImagePoint = 5
const GOLD = 'gold'
const TREE = 'tree'
const WATER = 'water'
const FIRE = 'fire'
const SOIL = 'soil'
const noiseGold = 'http://localhost:5000/%E9%92%9F.mp3'
const noiseTree = 'http://localhost:5000/%E6%A3%AE.mp3'
const noiseWater = 'http://localhost:5000/%E9%9B%A8.mp3'
const noiseFire = 'http://localhost:5000/%E7%81%AB.mp3'
const noiseSoil = 'http://localhost:5000/%E6%BD%AE.mp3'

let timer

export default class Index extends wepy.page {
  config = {
    navigationBarTitleText: '归心'
  }
  data = {
    mark: '../image/water.png',
    dates: '',
    showImge: false,
    tick: 0,
    time: '',
    key: ksStart,
    kStatus: ['开始', '暂停', '继续'],
    endKey: '结束',
    touchmove: true,
    changePoint: 0,
    imageNode: WATER,
    bgcolor: 'rgba(0, 255, 255, 0)',
    circlecolor: 'rgba(0, 0, 0, 0)',
    starPoint: [0, 0],
    curPoint: [0, 0],
    touches: [0, 0],
    noise: 'http://localhost:5000/雨.mp3',
    text: '森林'
  }
  methods = {
    date(self) {
      let date = new Date()
      const weeks = ['Sun', 'Mon', 'Tues', 'Wed', 'Thur', 'Fri', 'Sat']
      const week = date.getUTCDay()
      const weekd = weeks[week]
      const month = date.getMonth()
      const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'June', 'July', 'Aug', 'Sept', 'Oct', 'Nov', 'Dec']
      const mon = months[month]
      const day = date.getDate()
      const year = date.getFullYear()
      self.dates = mon + ' ' + day + ' ' + weekd + ' ' + year
    },
    // 判断是否开启计时器
    time() {
      let self = this
      let min = (self.tick - (self.tick % secondsPerMin)) / secondsPerMin
      self.methods.circleColorChange(self)
      self.methods.playnoise(self)
      if (min > timeLowlimit && min <= timeUplimit) {
        self.methods.timer(self)
      } else {
        self.key = ksPause
      }
    },
    // 计时器
    timer(self) {
      self.touchmove = false
      if (self.key === ksStart || self.key === ksContinue) {
        timer = setInterval(function() {
          self.tick--
          self.methods.setTime(self, self.tick)
          wepy.getBackgroundAudioPlayerState({
            success: function(res) {
              if (res.status !== 1) {
                self.methods.playnoise(self)
              }
            }
          })
          if (self.tick === timeLowlimit) {
            self.setData({
              touchmove: true,
              circlecolor: 'rgba(0, 0, 0, 0)',
              key: ksStart,
              tick: initialTime * secondsPerMin,
              time: initialTimeText
            })
            wepy.stopBackgroundAudio()
            self.time = initialTimeText
            self.tick = initialTime * secondsPerMin
            self.touchmove = true
            self.circlecolor = 'rgba(0, 0, 0, 0)'
            self.key = ksStart
            clearInterval(timer)
          }
        }, 1000)
        self.key = ksPause
      } else {
        wepy.pauseBackgroundAudio()
        self.methods.setTime(self, self.tick)
        clearInterval(timer)
        self.key = ksContinue
        self.circlecolor = 'rgba(255, 255, 0, 0.1)'
      }
    },
    // 刷新时间
    setTime(self, tick) {
      let currentTime = self.methods.currentTime(self.tick)
      self.setData({
        time: currentTime
      })
      self.time = currentTime
    },
    timerEnd() {
      let self = this
      clearInterval(timer)
      wepy.stopBackgroundAudio()
      self.key = ksStart
      self.tick = initialTime * secondsPerMin
      self.time = initialTimeText
      self.touchmove = true
      self.circlecolor = 'rgba(0, 0, 0, 0)'
    },
    // 计算时间及输出格式
    currentTime(tick) {
      let min = (tick - (tick % secondsPerMin)) / secondsPerMin
      let sec = tick % secondsPerMin
      if (min > timeUplimit) {
        return '∞'
      } else {
        if (min < 10) {
          min = '0' + min
        }
        if (sec < 10) {
          sec = '0' + sec
        }
        return min + ':' + sec
      }
    },
    touchstart(e) {
      let self = this
      self.starPoint = [e.touches[0].pageX, e.touches[0].pageY]
    },
    touchmove(e) {
      let self = this
      self.curPoint = [e.touches[0].pageX, e.touches[0].pageY]
      self.changePoint++
      if (self.touchmove) {
        self.methods.timeChange(self)
      }
    },
    touchend(e) {
      let self = this
      if (self.touchmove) {
        self.methods.imageChange(self)
      }
    },
    // 上下滑动调节时间
    timeChange(self) {
      let xchange = self.curPoint[xPos] - self.starPoint[xPos]
      let ychange = self.curPoint[yPos] - self.starPoint[yPos]
      if (Math.abs(xchange) < Math.abs(ychange)) {
        if (self.changePoint > changeTimePoint) {
          if (self.curPoint[yPos] > self.starPoint[yPos] && self.tick > 0) {
            self.tick = self.tick - secondsPerMin
            self.methods.setTime(self, self.tick)
            self.changePoint = 0
          }
          if (self.curPoint[yPos] < self.starPoint[yPos]) {
            self.tick = self.tick + secondsPerMin
            self.methods.setTime(self, self.tick)
            self.changePoint = 0
          }
        }
      }
    },
    // 左右滑动调节图片
    imageChange(self) {
      let xchange = self.curPoint[xPos] - self.starPoint[xPos]
      let ychange = self.curPoint[yPos] - self.starPoint[yPos]
      if (Math.abs(xchange) > Math.abs(ychange)) {
        if (self.changePoint > changeImagePoint) {
          if (self.curPoint[xPos] > self.starPoint[xPos]) {
            switch (self.imageNode) {
              case GOLD:
                break
              case TREE:
                self.mark = '../image/gold.png'
                self.imageNode = GOLD
                self.bgcolor = 'rgba( 255, 255, 0, 0.3)'
                self.noise = noiseGold
                break
              case WATER:
                self.mark = '../image/tree.png'
                self.imageNode = TREE
                self.bgcolor = 'rgba( 0, 255, 0, 0.3)'
                self.noise = noiseTree
                break
              case FIRE:
                self.mark = '../image/water.png'
                self.imageNode = WATER
                self.bgcolor = 'rgba(0, 255, 255, 0.3)'
                self.noise = noiseWater
                break
              case SOIL:
                self.mark = '../image/fire.png'
                self.imageNode = FIRE
                self.bgcolor = 'rgba( 255, 0, 0, 0.3)'
                self.noise = noiseFire
                break
            }
            self.changePoint = 0
          } else if (self.curPoint[xPos] < self.starPoint[xPos]) {
            switch (self.imageNode) {
              case GOLD:
                self.mark = '../image/tree.png'
                self.imageNode = TREE
                self.bgcolor = 'rgba( 0, 255, 0, 0.3)'
                self.noise = noiseTree
                break
              case TREE:
                self.mark = '../image/water.png'
                self.imageNode = WATER
                self.bgcolor = 'rgba(0, 255, 255, 0.3)'
                self.noise = noiseWater
                break
              case WATER:
                self.mark = '../image/fire.png'
                self.imageNode = FIRE
                self.bgcolor = 'rgba( 255, 0, 0, 0.3)'
                self.noise = noiseFire
                break
              case FIRE:
                self.mark = '../image/soil.png'
                self.imageNode = SOIL
                self.bgcolor = 'rgba( 238, 99, 99, 0.3)'
                self.noise = noiseSoil
                break
              case SOIL:
                break
            }
            self.changePoint = 0
          }
        }
      }
    },
    playnoise(self) {
      wepy.playBackgroundAudio({
        dataUrl: self.noise
      })
    },
    circleColorChange(self) {
      switch (self.imageNode) {
        case GOLD:
          self.circlecolor = 'rgba( 255, 255, 0, 0.3)'
          break
        case TREE:
          self.circlecolor = 'rgba( 0, 255, 0, 0.3)'
          break
        case WATER:
          self.circlecolor = 'rgba(0, 255, 255, 0.3)'
          break
        case FIRE:
          self.circlecolor = 'rgba( 255, 0, 0, 0.3)'
          break
        case SOIL:
          self.circlecolor = 'rgba( 238, 99, 99, 0.3)'
          break
      }
    }
  }
  onShareAppMessage() {
    return {
      title: '归心',
      desc: '都市喧闹 何处归心',
      path: '/page/noise'
    }
  }
  onLoad() {
    let self = this
    self.methods.date(self)
    setTimeout(() => {
      self.showImge = false
      self.setData({
        showImge: false
      })
    }, 2000)
    self.time = initialTimeText
    self.tick = initialTime * secondsPerMin
  }
}
</script>
