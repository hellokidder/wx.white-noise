<style lang="less">
.position {
  position: fixed;
  bottom: 0;
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  background-image: url('https://timgsa.baidu.com/timg?image&quality=80&size=b10000_10000&sec=1507874324&di=35d625e5e928c9af293703f3d4d90732&src=http://img4.duitang.com/uploads/item/201409/09/20140909211122_wWVay.png');
  background-size: 100% 100%;
}

.markposition {
  position: fixed;
  bottom: 0;
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
}

.top {
  position: fixed;
  bottom: 0;
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
}

.mark {
  width: 80px;
  height: 80px;
}

.text {
  width: 100%;
  height: 10%;
}

.yuan {
  width: 200px;
  height: 200px;
  border: 1px solid white;
  border-radius: 100px;
}

.center {
  display: flex;
  justify-content: center;
  align-items: center;
}

.time {
  color: white;
  border-bottom: 1px solid white;
  border-top: 1px solid white;
  margin-top: 20%;
}

.timefloor {
  margin-top: 7%;
  color: white;
  font-size: 20px;
}

.key {
  margin-top: 38%;
  display: flex;
  flex-direction: row;
  color: white;
  width: 100%;
}
</style>
<template>
  <view>
    <view wx:if="{{showImg}}">
      <image src="../image/bg.jpeg" class="top"></image>
    </view>
    <view wx:else class="position" @touchstart="touchstart" @touchmove="touchmove" @touchend="touchend">
      <view class="markposition" style="background-color:{{bgcolor}}">
        <view class="top">
          <view class="text"></view>
          <view class="yuan center">
            <view style="display: flex; flex-direction: column;">
              <view class="center">
                <image class="mark" src="{{mark}}"></image>
              </view>
              <text class="time">{{dates}}</text>
            </view>
          </view>
          <view class="center timefloor">
            <text>{{time}} </text>
          </view>
          <view wx:if="{{key === 0}}" @tap="floor" class="key center">
            <text>{{kStatus[key]}}</text>
          </view>
          <view wx:else class="key center">
            <view @tap="floor" style="margin-right: 8%;">
              <text>{{kStatus[key]}}</text>
            </view>
            <view @tap="floorEnd" style="margin-left: 8%;">
              <text>{{kStatus[ksStop]}}</text>
            </view>
          </view>
          <view>
            <text></text>
          </view>
        </view>
      </view>
    </view>
  </view>
</template>
<script>
import wepy from 'wepy'

const initialTime = 20
const initialTimeText = '20 : 00'
const secondsPerMin = 60
const changeTimePoint = 5
const changeImagePoint = 10
const timeTopPoint = 60
const timeLowPoint = 0
const bitsPoint = 10
const Xpos = 0
const Ypos = 1
let timer = null
const ksStart = 0
const ksPause = 1
const ksContinue = 2

export default class Water extends wepy.page {
  config = {
    navigationBarTitleText: '归心'
  }
  data = {
    switch: true,
    showImg: true,
    mark: '../image/water.png',
    starPoint: [0, 0],
    curPoint: [0, 0],
    bgcolor: 'rgba(0, 255, 255, 0.3)',
    imageNode: 'water',
    tick: 0,
    key: ksStart,
    dates: '',
    changePoint: 0,
    time: '',
    kStatus: ['开始', '暂停', '继续', '结束'],
    ksStop: 3
  }
  methods = {
    timeChange(self, e) {
      let xchange = self.curPoint[Xpos] - self.starPoint[Xpos]
      let ychange = self.curPoint[Ypos] - self.starPoint[Ypos]
      let currentTime
      if (self.curPoint[Xpos] >= self.starPoint[Xpos]) {
        if (Math.abs(xchange) >= Math.abs(ychange)) {
          self.changePoint = self.changePoint + 1
          console.log(self.changePoint)
        } else {
          if (self.curPoint[Ypos] >= self.starPoint[Ypos]) {
            if ((self.tick / secondsPerMin) > timeLowPoint) {
              self.changePoint = self.changePoint + 1
              if (self.changePoint === changeTimePoint) {
                self.tick = self.tick - secondsPerMin
                currentTime = (self.tick / secondsPerMin) >= timeTopPoint ? '∞' : (((self.tick - (self.tick % secondsPerMin)) / secondsPerMin) < bitsPoint ? '0' + ((self.tick - (self.tick % secondsPerMin)) / secondsPerMin) : ((self.tick - (self.tick % secondsPerMin)) / secondsPerMin)) + ' : ' + ((self.tick % secondsPerMin) >= bitsPoint ? (self.tick % secondsPerMin) : '0' + (self.tick % secondsPerMin))
                self.changePoint = 0
                self.time = currentTime
                self.setData({
                  time: currentTime
                })
              }
            }
          } else {
            if ((self.tick / secondsPerMin) < timeTopPoint) {
              self.changePoint = self.changePoint + 1
              if (self.changePoint === changeTimePoint) {
                self.tick = self.tick + secondsPerMin
                currentTime = (self.tick / secondsPerMin) >= timeTopPoint ? '∞' : (((self.tick - (self.tick % secondsPerMin)) / secondsPerMin) < bitsPoint ? '0' + ((self.tick - (self.tick % secondsPerMin)) / secondsPerMin) : ((self.tick - (self.tick % secondsPerMin)) / secondsPerMin)) + ' : ' + ((self.tick % secondsPerMin) >= bitsPoint ? (self.tick % secondsPerMin) : '0' + (self.tick % secondsPerMin))
                self.changePoint = 0
                self.time = currentTime
                self.setData({
                  time: currentTime
                })
                console.log(self.time, currentTime)
              }
            }
          }
        }
      } else {
        if (Math.abs(xchange) >= Math.abs(ychange)) {
          self.changePoint = self.changePoint + 1
        } else {
          if (self.curPoint[Ypos] >= self.starPoint[Ypos]) {
            if ((self.tick / secondsPerMin) > timeLowPoint) {
              self.changePoint = self.changePoint + 1
              if (self.changePoint === changeTimePoint) {
                self.tick = self.tick - secondsPerMin
                currentTime = (self.tick / secondsPerMin) >= timeTopPoint ? '∞' : (((self.tick - (self.tick % secondsPerMin)) / secondsPerMin) < bitsPoint ? '0' + ((self.tick - (self.tick % secondsPerMin)) / secondsPerMin) : ((self.tick - (self.tick % secondsPerMin)) / secondsPerMin)) + ' : ' + ((self.tick % secondsPerMin) >= bitsPoint ? (self.tick % secondsPerMin) : '0' + (self.tick % secondsPerMin))
                self.changePoint = 0
                self.time = currentTime
                self.setData({
                  time: currentTime
                })
              }
            }
          } else {
            if ((self.tick / secondsPerMin) < timeTopPoint) {
              self.changePoint = self.changePoint + 1
              if (self.changePoint === changeTimePoint) {
                self.tick = self.tick + secondsPerMin
                currentTime = (self.tick / secondsPerMin) >= timeTopPoint ? '∞' : (((self.tick - (self.tick % secondsPerMin)) / secondsPerMin) < bitsPoint ? '0' + ((self.tick - (self.tick % secondsPerMin)) / secondsPerMin) : ((self.tick - (self.tick % secondsPerMin)) / secondsPerMin)) + ' : ' + ((self.tick % secondsPerMin) >= bitsPoint ? (self.tick % secondsPerMin) : '0' + (self.tick % secondsPerMin))
                self.changePoint = 0
                self.time = currentTime
                self.setData({
                  time: currentTime
                })
              }
            }
          }
        }
      }
    },

    imageChange(self, e) {
      let xchange = self.curPoint[Xpos] - self.starPoint[Xpos]
      let ychange = self.curPoint[Ypos] - self.starPoint[Ypos]

      if (self.curPoint[Xpos] >= self.starPoint[Xpos]) {
        if (Math.abs(xchange) >= Math.abs(ychange)) {
          if (self.changePoint > changeImagePoint) {
            switch (self.imageNode) {
              case 'gold': 
                break
              case 'tree':
                self.mark = '../image/gold.png'
                self.imageNode = 'gold'
                self.bgcolor = 'rgba( 255, 255, 0, 0.3)'
                break
              case 'water':
                self.mark = '../image/tree.png'
                self.imageNode = 'tree'
                self.bgcolor = 'rgba( 0, 255, 0, 0.3)'
                break
              case 'fire':
                self.mark = '../image/water.png'
                self.imageNode = 'water'
                self.bgcolor = 'rgba(0, 255, 255, 0.3)'
                break
              case 'soil':
                self.mark = '../image/fire.png'
                self.imageNode = 'fire'
                self.bgcolor = 'rgba( 255, 0, 0, 0.3)'
                break
            }
            self.changePoint = 0
            console.log(self.changePoint)
          }
        } else {
          if (self.curPoint[Ypos] >= self.starPoint[Ypos]) {
          } else {
          }
        }
      } else {
        if (Math.abs(xchange) >= Math.abs(ychange)) {
          if (self.changePoint > changeImagePoint) {
            switch (self.imageNode) {
              case 'gold':
                self.mark = '../image/tree.png'
                self.imageNode = 'tree'
                self.bgcolor = 'rgba( 0, 255, 0, 0.3)'
                break
              case 'tree':
                self.mark = '../image/water.png'
                self.imageNode = 'water'
                self.bgcolor = 'rgba(0, 255, 255, 0.3)'
                break
              case 'water':
                self.mark = '../image/fire.png'
                self.imageNode = 'fire'
                self.bgcolor = 'rgba( 255, 0, 0, 0.3)'
                break
              case 'fire':
                self.mark = '../image/soil.png'
                self.imageNode = 'soil'
                self.bgcolor = 'rgba( 238, 99, 99, 0.3)'
                break
              case 'soil':
                break
            }
            self.changePoint = 0
          }
        } else {
          if (self.curPoint[Ypos] >= self.starPoint[Ypos]) {
          } else {
          }
        }
      }
    },

    touchstart(e) {
      console.log('star')
      let self = this
      self.starPoint = [e.touches[0].pageX, e.touches[0].pageY]
    },
    touchmove(e) {
      console.log('move')
      let self = this
      self.curPoint = [e.touches[0].pageX, e.touches[0].pageY]
      if (self.switch) {
        self.methods.timeChange(self, e)
      }
    },

    touchend(e) {
      console.log('end')
      let self = this
      if (self.switch) {
        self.methods.imageChange(self, e)
      }
    },

    floor() {
      let self = this
      let currentTime
      if (self.key === ksStart || self.key === ksContinue) {
        if (self.time === '∞') {
          self.key = ksPause
          self.switch = false
        } else {
          let tickCount = self.tick
          timer = setInterval(() => {
            tickCount--
            self.setData({
              tick: tickCount
            })
            self.tick = tickCount

            if (self.tick === timeLowPoint) {
              clearInterval(timer)
            }
            console.log(self.tick)
            currentTime = (self.tick / secondsPerMin) >= timeTopPoint ? '∞' : (((self.tick - (self.tick % secondsPerMin)) / secondsPerMin) < bitsPoint ? '0' + ((self.tick - (self.tick % secondsPerMin)) / secondsPerMin) : ((self.tick - (self.tick % secondsPerMin)) / secondsPerMin)) + ' : ' + ((self.tick % secondsPerMin) >= bitsPoint ? (self.tick % secondsPerMin) : '0' + (self.tick % secondsPerMin))
            self.setData({
              time: currentTime
            })
            self.time = currentTime
          }, 1000)
          self.key = ksPause
          self.switch = false
        }
      } else {
        self.key = ksContinue
        currentTime = (self.tick / secondsPerMin) >= timeTopPoint ? '∞' : (((self.tick - (self.tick % secondsPerMin)) / secondsPerMin) < bitsPoint ? '0' + ((self.tick - (self.tick % secondsPerMin)) / secondsPerMin) : ((self.tick - (self.tick % secondsPerMin)) / secondsPerMin)) + ' : ' + ((self.tick % secondsPerMin) >= bitsPoint ? (self.tick % secondsPerMin) : '0' + (self.tick % secondsPerMin))
        self.setData({
          time: currentTime
        })
        self.time = currentTime
        console.log(self.time)
        clearInterval(timer)
      }
    },
    floorEnd() {
      let self = this
      clearInterval(timer)
      self.key = ksStart
      self.tick = initialTime * secondsPerMin
      self.time = initialTimeText
      self.switch = true
    }
  }
  onShareAppMessage() {
    return {
      title: '归心',
      desc: '都市喧闹 何处归心',
      path: '/page/noise'
    }
  }

  onLoad() {
    let date = new Date()
    let self = this
    const weeks = ['Sun', 'Mon', 'Tues', 'Wed', 'Thur', 'Fri', 'Sat']
    const week = date.getUTCDay()
    const weekd = weeks[week]
    const month = date.getMonth()
    const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'June', 'July', 'Aug', 'Sept', 'Oct', 'Nov', 'Dec']
    const mon = months[month]
    const day = date.getDate()
    const year = date.getFullYear()
    self.dates = mon + ' ' + day + ' ' + weekd + ' ' + year
    self.tick = initialTime * secondsPerMin
    self.time = (self.tick / secondsPerMin) + ' : 0' + (self.tick % secondsPerMin)
    setTimeout(() => {
      self.showImg = false
      self.setData({
        showImg: false
      }}
    }, 2000)
    // wepy.request({
    //   url: 'http://127.0.0.1:7001/voice/list',
    //   success: function(res) {
    //     console.log(res)
    //   }
    // })
  }
}
</script>
